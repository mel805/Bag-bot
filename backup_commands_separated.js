const { SlashCommandBuilder, EmbedBuilder, ActionRowBuilder, StringSelectMenuBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const DualBackupSystem = require('./dual_backup_system_7days');
const FreeboxSync = require('./freebox_sync_7days');

/**
 * Commandes Discord s√©par√©es pour la gestion des sauvegardes
 * /backup - Forcer une sauvegarde
 * /restorer - Restauration avec s√©lecteur pagin√©
 */

class BackupCommandsSeparated {
  constructor() {
    this.backupSystem = new DualBackupSystem('./data/config.json', './data/backups');
    this.freeboxSync = new FreeboxSync('./data/backups', '/var/data/bot-backups');
  }

  /**
   * D√©finitions des commandes slash
   */
  getSlashCommands() {
    return [
      // Commande pour forcer une sauvegarde (simple)
      new SlashCommandBuilder()
        .setName('backup')
        .setDescription('Forcer la cr√©ation d\'une sauvegarde imm√©diate'),
      
      // Commande pour restaurer avec s√©lecteur
      new SlashCommandBuilder()
        .setName('restorer')
        .setDescription('Restaurer une sauvegarde avec s√©lecteur pagin√©')
        .addStringOption(option =>
          option
            .setName('timestamp')
            .setDescription('Timestamp sp√©cifique (optionnel, sinon utilise le s√©lecteur)')
            .setRequired(false)
        )
    ];
  }

  /**
   * Gestionnaire de la commande /backup
   */
  async handleBackupCommand(interaction) {
    // V√©rifier les permissions (admin seulement)
    if (!interaction.member.permissions.has('Administrator')) {
      return await interaction.reply({
        content: '‚ùå Seuls les administrateurs peuvent forcer une sauvegarde.',
        ephemeral: true
      });
    }

    await interaction.deferReply();

    try {
      const startTime = Date.now();
      
      console.log('üîÑ Sauvegarde forc√©e d√©marr√©e par', interaction.user.tag);
      
      // Cr√©er la sauvegarde
      const backupResult = this.backupSystem.createBackup();
      
      if (!backupResult) {
        return await interaction.editReply({
          content: '‚ùå √âchec de la cr√©ation de sauvegarde. V√©rifiez les logs du serveur.'
        });
      }

      // Synchroniser avec Freebox
      const syncResult = this.freeboxSync.syncToFreebox();
      
      // Nettoyer les anciennes sauvegardes
      this.backupSystem.cleanOldBackups();
      this.freeboxSync.cleanFreeboxBackups();
      
      const duration = Date.now() - startTime;
      
      const embed = new EmbedBuilder()
        .setTitle('‚úÖ Sauvegarde Forc√©e R√©ussie')
        .setDescription('La sauvegarde a √©t√© cr√©√©e avec succ√®s')
        .addFields(
          { name: 'üìã Configuration', value: `${Math.round(backupResult.configSize || 0)} KB`, inline: true },
          { name: 'üë• Donn√©es Users', value: `${Math.round(backupResult.userDataSize || 0)} KB`, inline: true },
          { name: '‚è±Ô∏è Dur√©e', value: `${duration}ms`, inline: true },
          { name: '‚òÅÔ∏è Freebox', value: syncResult ? '‚úÖ Synchronis√©' : '‚ö†Ô∏è √âchec sync', inline: true },
          { name: 'üìÖ Timestamp', value: backupResult.timestamp || 'Inconnu', inline: true },
          { name: 'üîÑ Demand√© par', value: interaction.user.toString(), inline: true }
        )
        .setColor(0x00FF00)
        .setTimestamp();

      return await interaction.editReply({ embeds: [embed] });

    } catch (error) {
      console.error('‚ùå Erreur sauvegarde forc√©e:', error);
      return await interaction.editReply({
        content: `‚ùå Erreur lors de la sauvegarde: ${error.message}`
      });
    }
  }

  /**
   * Gestionnaire de la commande /restorer
   */
  async handleRestorerCommand(interaction) {
    // V√©rifier les permissions (admin seulement)
    if (!interaction.member.permissions.has('Administrator')) {
      return await interaction.reply({
        content: '‚ùå Seuls les administrateurs peuvent restaurer des sauvegardes.',
        ephemeral: true
      });
    }

    const timestamp = interaction.options.getString('timestamp');
    
    if (timestamp) {
      // Restauration directe par timestamp
      return await this.handleDirectRestore(interaction, timestamp);
    } else {
      // Afficher le s√©lecteur pagin√©
      return await this.handleRestorerSelector(interaction);
    }
  }

  /**
   * Restauration directe par timestamp
   */
  async handleDirectRestore(interaction, timestamp) {
    await interaction.deferReply();

    try {
      const allBackups = this.getAllAvailableBackups();
      const backup = allBackups.find(b => b.timestamp === timestamp);

      if (!backup) {
        return await interaction.editReply({
          content: `‚ùå Sauvegarde introuvable: \`${timestamp}\`\nüí° Utilisez \`/restorer\` sans param√®tre pour voir les sauvegardes disponibles.`
        });
      }

      // Confirmation embed
      const confirmEmbed = new EmbedBuilder()
        .setTitle('‚ö†Ô∏è Confirmation de Restauration')
        .setDescription(`Voulez-vous restaurer cette sauvegarde ?\n\n**‚ö†Ô∏è ATTENTION: Cela remplacera la configuration actuelle !**`)
        .addFields(
          { name: 'üìÖ Timestamp', value: backup.timestamp, inline: true },
          { name: 'üìç Emplacement', value: backup.location === 'local' ? 'üè† Local' : '‚òÅÔ∏è Freebox', inline: true },
          { name: 'üìä Taille', value: `Config: ${backup.configSize}KB\nDonn√©es: ${backup.userDataSize}KB`, inline: true },
          { name: '‚è∞ √Çge', value: backup.age, inline: true },
          { name: 'üîÑ Demand√© par', value: interaction.user.toString(), inline: true }
        )
        .setColor(0xFF9900);

      const confirmRow = new ActionRowBuilder()
        .addComponents(
          new ButtonBuilder()
            .setCustomId(`restore_confirm_${timestamp}`)
            .setLabel('‚úÖ Confirmer')
            .setStyle(ButtonStyle.Danger),
          new ButtonBuilder()
            .setCustomId('restore_cancel')
            .setLabel('‚ùå Annuler')
            .setStyle(ButtonStyle.Secondary)
        );

      return await interaction.editReply({
        embeds: [confirmEmbed],
        components: [confirmRow]
      });

    } catch (error) {
      console.error('‚ùå Erreur restauration directe:', error);
      return await interaction.editReply({
        content: `‚ùå Erreur lors de la restauration: ${error.message}`
      });
    }
  }

  /**
   * Afficher le s√©lecteur pagin√© de restauration
   */
  async handleRestorerSelector(interaction) {
    await interaction.deferReply();

    try {
      const allBackups = this.getAllAvailableBackups();
      
      if (allBackups.length === 0) {
        return await interaction.editReply({
          content: '‚ùå Aucune sauvegarde trouv√©e.'
        });
      }

      // Afficher la premi√®re page
      return await this.displayBackupPage(interaction, allBackups, 0);

    } catch (error) {
      console.error('‚ùå Erreur s√©lecteur restauration:', error);
      return await interaction.editReply({
        content: `‚ùå Erreur lors de la r√©cup√©ration des sauvegardes: ${error.message}`
      });
    }
  }

  /**
   * Affiche une page de sauvegardes avec navigation
   */
  async displayBackupPage(interaction, allBackups, page) {
    const pageSize = 10;
    const maxPage = Math.ceil(allBackups.length / pageSize) - 1;
    const startIndex = page * pageSize;
    const endIndex = Math.min(startIndex + pageSize, allBackups.length);
    const pageBackups = allBackups.slice(startIndex, endIndex);

    // Cr√©er l'embed
    const embed = new EmbedBuilder()
      .setTitle('üîÑ S√©lecteur de Restauration')
      .setDescription(`Page ${page + 1}/${maxPage + 1} ‚Ä¢ ${allBackups.length} sauvegardes disponibles`)
      .setColor(0x0099FF)
      .setTimestamp();

    // Ajouter les sauvegardes de la page
    let description = '';
    pageBackups.forEach((backup, index) => {
      const globalIndex = startIndex + index + 1;
      const icon = backup.location === 'local' ? 'üè†' : '‚òÅÔ∏è';
      const dateStr = backup.date.toLocaleString('fr-FR', {
        day: '2-digit',
        month: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
      
      description += `**${globalIndex}.** ${icon} \`${backup.timestamp}\`\n`;
      description += `üìÖ ${dateStr} ‚Ä¢ ‚è∞ ${backup.age}\n`;
      description += `üìã ${backup.configSize}KB ‚Ä¢ üë• ${backup.userDataSize}KB\n\n`;
    });

    embed.setDescription(description);

    // Cr√©er les boutons de navigation
    const row = new ActionRowBuilder();

    // Bouton page pr√©c√©dente
    row.addComponents(
      new ButtonBuilder()
        .setCustomId(`restorer_prev_${page}`)
        .setLabel('‚óÄ Pr√©c√©dent')
        .setStyle(ButtonStyle.Secondary)
        .setDisabled(page === 0)
    );

    // Bouton refresh
    row.addComponents(
      new ButtonBuilder()
        .setCustomId(`restorer_refresh_${page}`)
        .setLabel('üîÑ Actualiser')
        .setStyle(ButtonStyle.Primary)
    );

    // Bouton page suivante
    row.addComponents(
      new ButtonBuilder()
        .setCustomId(`restorer_next_${page}`)
        .setLabel('Suivant ‚ñ∂')
        .setStyle(ButtonStyle.Secondary)
        .setDisabled(page === maxPage)
    );

    // Menu de s√©lection pour restauration rapide
    const selectMenu = new StringSelectMenuBuilder()
      .setCustomId('restorer_select')
      .setPlaceholder('S√©lectionner une sauvegarde √† restaurer...')
      .addOptions(
        pageBackups.map((backup, index) => ({
          label: `${backup.timestamp} (${backup.location})`,
          description: `${backup.date.toLocaleString('fr-FR')} ‚Ä¢ ${backup.configSize + backup.userDataSize}KB`,
          value: backup.timestamp,
          emoji: backup.location === 'local' ? 'üè†' : '‚òÅÔ∏è'
        }))
      );

    const selectRow = new ActionRowBuilder().addComponents(selectMenu);

    if (interaction.replied || interaction.deferred) {
      return await interaction.editReply({
        embeds: [embed],
        components: [row, selectRow]
      });
    } else {
      return await interaction.reply({
        embeds: [embed],
        components: [row, selectRow]
      });
    }
  }

  /**
   * R√©cup√®re toutes les sauvegardes disponibles (local + Freebox)
   */
  getAllAvailableBackups() {
    const allBackups = [];
    
    // Sauvegardes locales
    const localBackups = this.backupSystem.getAllBackups();
    localBackups.forEach(backup => {
      backup.location = 'local';
      allBackups.push(backup);
    });
    
    // Sauvegardes Freebox
    try {
      const { execSync } = require('child_process');
      const fs = require('fs');
      const path = require('path');
      
      const freeboxConfigs = execSync('ls /var/data/bot-backups/config/bot-config_*.json 2>/dev/null | sort -r || echo ""', { encoding: 'utf8' }).trim();
      
      if (freeboxConfigs) {
        const configFiles = freeboxConfigs.split('\n').filter(f => f);
        
        configFiles.forEach(configPath => {
          const fileName = path.basename(configPath);
          const timestamp = fileName.match(/(\d{4}-\d{2}-\d{2}_\d{2}h\d{2})/)?.[1];
          
          if (timestamp) {
            const userDataPath = `/var/data/bot-backups/userdata/user-data_${timestamp}.json`;
            
            if (fs.existsSync(userDataPath)) {
              try {
                const configStats = fs.statSync(configPath);
                const userDataStats = fs.statSync(userDataPath);
                
                // √âviter les doublons avec les sauvegardes locales
                if (!allBackups.find(b => b.timestamp === timestamp)) {
                  allBackups.push({
                    timestamp,
                    configFile: fileName,
                    userDataFile: `user-data_${timestamp}.json`,
                    configSize: Math.round(configStats.size / 1024),
                    userDataSize: Math.round(userDataStats.size / 1024),
                    date: configStats.mtime,
                    age: this.backupSystem.getAge(configStats.mtime),
                    location: 'freebox',
                    configPath,
                    userDataPath
                  });
                }
              } catch (error) {
                // Ignorer les erreurs de lecture de fichiers
              }
            }
          }
        });
      }
    } catch (error) {
      console.log('‚ö†Ô∏è Impossible de lire les sauvegardes Freebox');
    }
    
    // Trier par date (plus r√©cent en premier)
    allBackups.sort((a, b) => new Date(b.date) - new Date(a.date));
    
    return allBackups;
  }

  /**
   * Gestionnaire des interactions (boutons et menus)
   */
  async handleRestorerInteraction(interaction) {
    if (interaction.isButton()) {
      return await this.handleRestorerButton(interaction);
    } else if (interaction.isStringSelectMenu()) {
      return await this.handleRestorerSelect(interaction);
    }
  }

  /**
   * Gestionnaire des boutons
   */
  async handleRestorerButton(interaction) {
    const [action, ...params] = interaction.customId.split('_');

    if (action === 'restorer') {
      const [subAction, page] = params;
      const currentPage = parseInt(page) || 0;
      const allBackups = this.getAllAvailableBackups();

      switch (subAction) {
        case 'prev':
          await this.displayBackupPage(interaction, allBackups, Math.max(0, currentPage - 1));
          break;
        case 'next':
          const maxPage = Math.ceil(allBackups.length / 10) - 1;
          await this.displayBackupPage(interaction, allBackups, Math.min(maxPage, currentPage + 1));
          break;
        case 'refresh':
          await this.displayBackupPage(interaction, allBackups, currentPage);
          break;
      }
    } else if (action === 'restore') {
      const [subAction, timestamp] = params;
      
      if (subAction === 'confirm') {
        await this.executeRestore(interaction, timestamp);
      } else if (subAction === 'cancel') {
        await interaction.update({
          content: '‚ùå Restauration annul√©e.',
          embeds: [],
          components: []
        });
      }
    }
  }

  /**
   * Gestionnaire du menu de s√©lection
   */
  async handleRestorerSelect(interaction) {
    const timestamp = interaction.values[0];
    
    // Rediriger vers la confirmation de restauration
    await this.handleDirectRestore({
      ...interaction,
      options: {
        getString: () => timestamp
      },
      deferReply: () => interaction.deferUpdate()
    }, timestamp);
  }

  /**
   * Ex√©cute la restauration
   */
  async executeRestore(interaction, timestamp) {
    await interaction.deferUpdate();

    try {
      const allBackups = this.getAllAvailableBackups();
      const backup = allBackups.find(b => b.timestamp === timestamp);

      if (!backup) {
        return await interaction.editReply({
          content: `‚ùå Sauvegarde introuvable: ${timestamp}`,
          components: []
        });
      }

      console.log(`üîÑ Restauration ${timestamp} d√©marr√©e par ${interaction.user.tag}`);

      let success = false;
      
      if (backup.location === 'local') {
        const configPath = `./data/backups/${backup.configFile}`;
        const userDataPath = `./data/backups/${backup.userDataFile}`;
        success = this.backupSystem.restoreFromBackup(configPath, userDataPath);
      } else {
        success = this.backupSystem.restoreFromBackup(backup.configPath, backup.userDataPath);
      }

      if (success) {
        const successEmbed = new EmbedBuilder()
          .setTitle('‚úÖ Restauration R√©ussie')
          .setDescription('La sauvegarde a √©t√© restaur√©e avec succ√®s')
          .addFields(
            { name: 'üìÖ Timestamp', value: backup.timestamp, inline: true },
            { name: 'üìç Source', value: backup.location === 'local' ? 'üè† Local' : '‚òÅÔ∏è Freebox', inline: true },
            { name: 'üîÑ Restaur√© par', value: interaction.user.toString(), inline: true }
          )
          .setColor(0x00FF00)
          .setTimestamp();

        const restartRow = new ActionRowBuilder()
          .addComponents(
            new ButtonBuilder()
              .setCustomId('restart_bot_info')
              .setLabel('‚ÑπÔ∏è Red√©marrage requis')
              .setStyle(ButtonStyle.Secondary)
              .setDisabled(true)
          );

        await interaction.editReply({
          content: '‚ö†Ô∏è **N\'oubliez pas de red√©marrer le bot** pour appliquer les changements !\n`pm2 restart bagbot`',
          embeds: [successEmbed],
          components: [restartRow]
        });
      } else {
        await interaction.editReply({
          content: `‚ùå √âchec de la restauration de \`${timestamp}\`. V√©rifiez les logs du serveur.`,
          components: []
        });
      }

    } catch (error) {
      console.error('‚ùå Erreur ex√©cution restauration:', error);
      await interaction.editReply({
        content: `‚ùå Erreur lors de la restauration: ${error.message}`,
        components: []
      });
    }
  }
}

module.exports = BackupCommandsSeparated;